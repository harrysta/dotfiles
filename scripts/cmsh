#!/bin/sh

func_yn() {
	printf "%s (y/n) " "$1"
	read -r choice
	case "$choice" in
		y|Y) ;;
		*)
			printf "Aborting.\n"
			exit 1
			;;
	esac
}

func_err() {
	printf "Error: %b\n" "$*" >&2
	exit 1
}

func_append_type() {
	if [ "$proj_types" = "" ]; then
		proj_types="$*"
	else
		proj_types="$proj_types:$*"
	fi
}

func_init() {
	# TODO ask the project type
	echo $1
	case "$1" in
		"cmake")
			echo "initialising cmake..."
		;;
		"meson")
			echo "initialising meson..."
		;;
		*)
		func_err "This build system is not supported."
		;;
	esac
}

func_setup_win() {
	case "$proj_type" in
		cmake)
			if [ ! -e "$SRC/lib/vcpkg" ]; then
				printf "Note: In order to build a project that requires external \
					libraries, vcpkg is required. Ensure it's sourced in $SRC/lib/vcpkg.\n"
			fi

			cmake -B "build" -S "." \
				-DCMAKE_TOOLCHAIN_FILE="$SRC/lib/vcpkg/scripts/buildsystems/vcpkg.cmake"

			;;
		meson)
			meson setup build
			;;
	esac
}


func_setup_other() {
	case "$proj_type" in
		cmake)
			# clean if previously setup with msvc
			sln_count="$(ls -l build/*.sln 2>/dev/null | wc -l)"
			if [ $sln_count -ne 0 ]; then
				func_clean
			fi

			cmake -B "build" -S "." -DCMAKE_EXPORT_COMPILE_COMMANDS=1
			rm -f compile_commands.json
			ln -s build/compile_commands.json .
			;;
		meson)
			meson setup build
	esac
}

func_setup() {
	if [ ! -d "build" ]; then
		if [ -e "build" ]; then
			printf "Error: failed to begin setup. Build is not a path.\n"
			return
		fi
		mkdir "./build"
	fi

	case "$curr_os" in
		windows)
			func_setup_win
			;;
		*)
			func_setup_other
			;;
	esac
}

func_build() {
	case "$proj_type" in
		cmake)
			cmake --build "build" --parallel 12
			;;
		meson)
			meson compile -C build
			;;
		cc)
			# TODO improve this; needs includes and libraries as well
			files=$(find . -type f -name "*.c")
			cc -o "./build/output" $files
			;;
		g++)
			files=$(find . -type f \( -name "*.c" -o -name "*.cc" -o -name "*.cxx" -o -name "*.cpp" \))
			g++ -o "./build/output" $files
			;;
		make)
			make
			;;
	esac
}

func_run_cmake() {
	exec_count=$(grep add_library CMakeLists.txt | wc -l)
	if [ $exec_count -ne 0 ]; then
		func_test
		return 0
	fi

	exec_name=$(grep add_executable CMakeLists.txt | head -1 | sed 's/[()]/ /g' \
		| awk '{ print $2 }')

	if [ $exec_name = "\${PROJECT_NAME}" ]; then
		exec_name=$(grep project CMakeLists.txt | head -1 | sed 's/[()]/ /g' \
			| awk '{ print $2 }')
	fi

	case "$curr_os" in
		windows)
			"./build/Debug/$exec_name.exe"
			;;
		*)
			"./build/$exec_name" "$cmdline_args"
			;;
	esac
}

func_run_meson() {
	exec_name=$(grep executable meson.build | sed 's/[()]/ /g' \
		| awk '{ print $2 }' | tr -cd '[:alnum:][:blank:]')

	if [ $exec_name = "\${PROJECT_NAME}" ]; then
		exec_name=$(grep project meson.build | sed 's/[()]/ /g' \
			| awk '{ print $2 }')
	fi

	echo $exec_name

	case "$curr_os" in
		windows)
			"./build/Debug/$exec_name.exe"
			;;
		*)
			"./build/$exec_name"
			;;
	esac
}

func_run() {
	case "$proj_type" in
		cmake)
			func_run_cmake
			;;
		meson)
			func_run_meson
			;;
	esac
}

func_clean() {
	rm -rf build/*
}

func_install() {
	case "$proj_type" in
		cmake)
			sudo -E cmake --install "build"
			;;
		meson)
			;;
	esac
}

func_test() {
	case "$proj_type" in
		cmake)
			if command -v "ctest" >/dev/null 2>&1; then
				:
			else
				func_err "Could not run tests; ctest is not installed."
			fi
			ctest --verbose --test-dir build
			;;
		meson)
			;;
	esac
}

# -----------------------------------------------------------------------------

# find OS

case "$(uname -s)" in
	Linux*)  curr_os=linux;;
	Darwin*) curr_os=macos;;
	CYGWIN*) curr_os=windows;;
	MINGW*)  curr_os=windows;;
	MSYS*)   curr_os=windows;;
	*)
		printf "Unknown OS: %s\n" "$(uname -s)"
		exit 1
		;;
esac

proj_types=""

# search for files of build systems

if [ -e "CMakeLists.txt" ]; then
	func_append_type "cmake"
fi

if [ -e "meson.build" ]; then
	func_append_type "meson"
fi

if [ -e "Makefile" ]; then
	func_append_type "make"
fi

# handle depending on count

proj_type_count=$(echo "$proj_types" | tr ":" "\n" | awk NF | awk 'END{ print NR }')
case "$proj_type_count" in
	0)
		cpp_files=$(find . -type f \( -name "*.cc" -o -name "*.cxx" -o -name "*.cpp" \))

		if [ -n "$cpp_files" ]; then
			proj_type="g++"
		else
			proj_type="cc"
		fi
		;;
	1)
		proj_type="$proj_types"
		;;
	*)
		printf "Multiple build systems found. Choose 1-%s ('q' to quit):\n" "$proj_type_count"
		idx=1
		for type in $(echo "$proj_types" | tr ":" "\n"); do
			printf "%s) %s\n" "$idx" "$type"
			idx=$(($idx + 1))
		done
		printf "> "
		read -r user_input
		case "$user_input" in
			1|2|3|4|5|6|7|8)
				proj_type=$(echo "$proj_types" | tr ":" "\n" | awk NF | sed -n "$user_input"p)
				;;
			q|Q)
				printf "Aborting.\n"
				exit 1
				;;
			*)
				func_err "Invalid input."
				;;
		esac
			;;
esac

if ! command -v "$proj_type" >/dev/null 2>&1; then
	printf "Error: Project is built with %s, but %s is not installed.\n" "$proj_type" "$proj_type"
	exit 1
fi

# print startup

printf "csh (%s, %s)\n" "$curr_os" "$proj_type"
curr_proj=$(basename "$(pwd)")

# read config

if [ -e ".csh" ]; then
	while IFS= read -r line; do
		eval "$line"
	done < .csh
fi

# start prompting

while true; do
	printf "%s\$ " "$curr_proj"
	read -r user_input

	case "$user_input" in
		init)
			func_init
			;;
		c)
			func_setup
			;;
		b)
			func_build
			;;
		r)
			func_run
			;;
		cb)
			func_setup && func_build
			;;
		br)
			func_build && func_run
			;;
		cbr)
			func_setup && func_build && func_run
			;;
		clean)
			func_clean
			;;
		install)
			func_install
			;;
		test)
			func_test
			;;
		q|Q)
			exit 0
			;;
		*)
			printf "csh: command not found\n"
			;;
		esac
done
